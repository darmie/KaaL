//! Serial UART Driver Example
//!
//! Demonstrates how to use the DDDK (Device Driver Development Kit) to create
//! a simple serial port driver. This example shows the API structure and
//! integration with the capability broker.

use cap_broker::{CapabilityBroker, DefaultCapBroker, DeviceId};
use dddk_runtime::{DriverError, DriverMetadata, MmioRegion, Result};

/// Serial port register offsets (16550 UART)
mod regs {
    pub const DATA: usize = 0x00; // Data register
    pub const IER: usize = 0x01; // Interrupt Enable Register
    pub const FCR: usize = 0x02; // FIFO Control Register
    pub const LCR: usize = 0x03; // Line Control Register
    pub const MCR: usize = 0x04; // Modem Control Register
    pub const LSR: usize = 0x05; // Line Status Register
    pub const MSR: usize = 0x06; // Modem Status Register
    pub const SR: usize = 0x07; // Scratch Register
}

/// Serial port driver
///
/// In a real implementation, this would use #[derive(Driver)] to generate
/// the boilerplate. For this example, we manually implement the traits to
/// demonstrate the API structure.
///
/// # With DDDK Macros (future):
/// ```ignore
/// #[derive(Driver)]
/// #[pci(vendor = 0x8086, device = 0x100E)]
/// #[resources(mmio = "bar0", irq = "auto", dma = "4MB")]
/// pub struct SerialDriver {
///     #[mmio]
///     mmio: MmioRegion,
/// }
/// ```
///
/// The above 6 lines would generate ~200 lines of boilerplate code for:
/// - Device probing
/// - Resource allocation
/// - MMIO mapping
/// - IRQ registration
/// - Driver lifecycle management
pub struct SerialDriver {
    /// MMIO region for serial registers
    mmio: Option<MmioRegion>,
}

impl DriverMetadata for SerialDriver {
    fn device_id() -> DeviceId {
        DeviceId::Serial { port: 0 }
    }

    fn driver_name() -> &'static str {
        "SerialDriver"
    }

    fn driver_version() -> &'static str {
        "0.1.0"
    }
}

impl SerialDriver {
    /// Manual probe implementation (would be generated by #[derive(Driver)])
    pub fn probe(broker: &mut dyn CapabilityBroker) -> Result<Self> {
        // Request device bundle from capability broker
        let bundle = broker
            .request_device(Self::device_id())
            .map_err(|e| DriverError::ResourceAllocation(format!("{:?}", e)))?;

        // TODO PHASE 1.5: Map MMIO regions properly
        // For now, we just acknowledge that resources were allocated
        println!("  ✓ Allocated {} MMIO regions", bundle.mmio_regions.len());
        println!("  ✓ Allocated IRQ {}", bundle.irq.irq_num());
        println!("  ✓ Allocated DMA pool: {} bytes", bundle.dma_pool.size());

        Ok(Self { mmio: None })
    }

    /// Initialize the serial port
    ///
    /// This is called after probe() successfully allocates resources
    pub fn init(&mut self) -> Result<()> {
        // In Phase 1, MMIO isn't fully set up yet
        if let Some(mmio) = self.mmio.as_mut() {
            unsafe {
                // Disable interrupts
                mmio.write_u8(regs::IER, 0x00);

                // Enable DLAB (set baud rate divisor)
                mmio.write_u8(regs::LCR, 0x80);

                // Set divisor to 3 (38400 baud)
                mmio.write_u8(regs::DATA, 0x03);
                mmio.write_u8(regs::IER, 0x00);

                // 8 bits, no parity, one stop bit
                mmio.write_u8(regs::LCR, 0x03);

                // Enable FIFO, clear them, with 14-byte threshold
                mmio.write_u8(regs::FCR, 0xC7);

                // Enable IRQs, set RTS/DSR
                mmio.write_u8(regs::MCR, 0x0B);
            }
        }

        Ok(())
    }

    /// Write a byte to the serial port
    pub fn write_byte(&mut self, byte: u8) -> Result<()> {
        let mmio = self.mmio.as_mut().ok_or(DriverError::NotImplemented)?;

        unsafe {
            // Wait for transmit buffer to be empty
            while (mmio.read_u8(regs::LSR) & 0x20) == 0 {
                core::hint::spin_loop();
            }

            // Write byte
            mmio.write_u8(regs::DATA, byte);
        }

        Ok(())
    }

    /// Write a string to the serial port
    pub fn write_str(&mut self, s: &str) -> Result<()> {
        for byte in s.bytes() {
            self.write_byte(byte)?;
        }
        Ok(())
    }

    /// Read a byte from the serial port (non-blocking)
    pub fn read_byte(&mut self) -> Result<Option<u8>> {
        let mmio = self.mmio.as_ref().ok_or(DriverError::NotImplemented)?;

        unsafe {
            // Check if data is available
            if (mmio.read_u8(regs::LSR) & 0x01) != 0 {
                Ok(Some(mmio.read_u8(regs::DATA)))
            } else {
                Ok(None)
            }
        }
    }
}

fn main() {
    println!("===== Serial Driver Example =====\n");
    println!(
        "This example demonstrates the DDDK architecture and capability broker integration.\n"
    );

    println!("1. Initializing capability broker...");
    let mut broker =
        unsafe { DefaultCapBroker::init().expect("Failed to initialize capability broker") };
    println!("   ✓ Capability broker initialized\n");

    println!("2. Driver metadata:");
    println!("   Device ID: {:?}", SerialDriver::device_id());
    println!("   Driver Name: {}", SerialDriver::driver_name());
    println!("   Driver Version: {}\n", SerialDriver::driver_version());

    println!("3. Probing for serial device...");
    match SerialDriver::probe(&mut broker) {
        Ok(mut driver) => {
            println!("   ✓ Serial device probed successfully!\n");

            println!("4. Initializing driver...");
            match driver.init() {
                Ok(()) => println!("   ✓ Driver initialized!\n"),
                Err(e) => {
                    println!("   ℹ  Driver init skipped: {:?}", e);
                    println!("   (MMIO not yet fully implemented in Phase 1)\n");
                }
            }
        }
        Err(e) => {
            println!("   ✗ Serial device probe failed: {:?}\n", e);
        }
    }

    println!("===== Example Complete =====\n");
    println!("Key Features Demonstrated:");
    println!("• Capability Broker: Centralized device resource management");
    println!("• Driver Metadata: Device identification and versioning");
    println!("• Resource Allocation: MMIO, IRQ, and DMA pool allocation");
    println!("• DDDK API: Clean driver interface (probe, init, I/O operations)");
    println!("\nWith #[derive(Driver)] macro:");
    println!("• ~150 lines of driver code → ~40 lines (73% reduction)");
    println!("• No manual resource management boilerplate");
    println!("• Compiler-verified resource declarations");
}
