# KaaL Bootable Image Builder Dockerfile
#
# Generic build tool for creating bootable seL4 images with KaaL's Rust elfloader.
#
# Build Arguments:
#   PROJECT_PATH - Path to the project/example to build (e.g., "examples/bootable-demo")
#   ROOT_TASK_LIB - Name of the root task library (e.g., "libkaal_bootable_demo.a")
#
# Usage:
#   docker build -f tools/Dockerfile.bootimage \
#     --build-arg PROJECT_PATH=examples/bootable-demo \
#     --build-arg ROOT_TASK_LIB=libkaal_bootable_demo.a \
#     -t kaal-bootable .

# ============================================================================
# Build Arguments
# ============================================================================
ARG PROJECT_PATH
ARG ROOT_TASK_LIB=libroot_task.a

# ============================================================================
# Stage 1: Build Environment Setup
# ============================================================================
FROM rust:1.75-slim AS builder-base

# Install build dependencies
RUN apt-get update && apt-get install -y \
    # Rust build tools
    build-essential \
    cmake ninja-build \
    pkg-config \
    # ARM64 cross-compilation
    gcc-aarch64-linux-gnu \
    g++-aarch64-linux-gnu \
    # seL4 dependencies
    libxml2-utils \
    device-tree-compiler \
    qemu-system-arm \
    # Utilities
    git curl wget \
    python3 python3-pip \
    file \
    # Cleanup
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies for seL4 kernel build
RUN pip3 install --break-system-packages pyyaml sel4-deps

# Install Rust toolchains and components
RUN rustup toolchain install nightly && \
    rustup default nightly && \
    rustup target add aarch64-unknown-none && \
    rustup component add rust-src rustfmt clippy

WORKDIR /build

# ============================================================================
# Stage 2: Build seL4 Kernel
# ============================================================================
FROM builder-base AS kernel-builder

# Clone seL4 kernel
RUN git clone --depth 1 --branch 13.0.0 https://github.com/seL4/seL4.git /build/kernel

# Build kernel
RUN mkdir -p /build/kernel/build && \
    cd /build/kernel/build && \
    cmake .. \
        -G Ninja \
        -DCROSS_COMPILER_PREFIX=aarch64-linux-gnu- \
        -DKernelPlatform=qemu-arm-virt \
        -DKernelSel4Arch=aarch64 \
        -DKernelDebugBuild=OFF \
        -DKernelPrinting=ON \
        -DKernelVerificationBuild=OFF && \
    ninja

# Verify kernel was built
RUN test -f /build/kernel/build/kernel.elf && \
    file /build/kernel/build/kernel.elf | grep "ARM aarch64"

# ============================================================================
# Stage 3: Build Elfloader
# ============================================================================
FROM builder-base AS elfloader-builder

# Copy elfloader source
COPY runtime/elfloader /build/runtime/elfloader

# Build elfloader for bare-metal ARM64
WORKDIR /build/runtime/elfloader

RUN cargo build --release \
    --target aarch64-unknown-none \
    -Z build-std=core,alloc \
    -Z build-std-features=compiler-builtins-mem

# Verify elfloader was built
RUN test -f target/aarch64-unknown-none/release/libkaal_elfloader.a && \
    file target/aarch64-unknown-none/release/libkaal_elfloader.a

# ============================================================================
# Stage 4: Build Root Task (from PROJECT_PATH argument)
# ============================================================================
FROM builder-base AS roottask-builder

# Receive build arguments
ARG PROJECT_PATH
ARG ROOT_TASK_LIB

# Validate PROJECT_PATH is provided
RUN if [ -z "$PROJECT_PATH" ]; then \
        echo "ERROR: PROJECT_PATH build argument is required"; \
        echo "Usage: docker build --build-arg PROJECT_PATH=examples/your-project ..."; \
        exit 1; \
    fi

# Copy entire KaaL source (for workspace dependencies)
COPY . /kaal-source

# Build the root task from specified project
WORKDIR /kaal-source/${PROJECT_PATH}

RUN echo "Building root task from: ${PROJECT_PATH}" && \
    echo "Expected output library: ${ROOT_TASK_LIB}" && \
    cargo build --release \
        --target aarch64-unknown-none \
        -Z build-std=core,alloc \
        -Z build-std-features=compiler-builtins-mem

# Verify root task was built
RUN test -f target/aarch64-unknown-none/release/${ROOT_TASK_LIB} && \
    file target/aarch64-unknown-none/release/${ROOT_TASK_LIB} && \
    echo "✓ Root task built successfully: ${ROOT_TASK_LIB}"

# ============================================================================
# Stage 5: Build Elfloader-Builder Tool
# ============================================================================
FROM builder-base AS builder-tool

# Copy elfloader-builder source
COPY runtime/elfloader-builder /build/runtime/elfloader-builder

WORKDIR /build/runtime/elfloader-builder

# Build the builder tool (host binary)
RUN cargo build --release

# Verify builder tool was built
RUN test -f target/release/kaal-elfloader-builder

# ============================================================================
# Stage 6: Link Root Task into ELF Executable
# ============================================================================
FROM builder-base AS roottask-linker

# Receive build arguments
ARG PROJECT_PATH
ARG ROOT_TASK_LIB

# Copy root task static library and linker script
COPY --from=roottask-builder /kaal-source/${PROJECT_PATH}/target/aarch64-unknown-none/release/${ROOT_TASK_LIB} /build/root-task.a
COPY tools/roottask.ld /build/roottask.ld

# Link root task library into executable ELF
WORKDIR /build
RUN mkdir -p /artifacts && \
    aarch64-linux-gnu-ld -T roottask.ld \
        --whole-archive /build/root-task.a --no-whole-archive \
        -o /artifacts/root-task.elf && \
    file /artifacts/root-task.elf && \
    aarch64-linux-gnu-readelf -h /artifacts/root-task.elf && \
    echo "✓ Root task linked into ELF executable"

# ============================================================================
# Stage 7: Assemble Bootable Image
# ============================================================================
FROM builder-base AS assembler

# Receive build arguments
ARG PROJECT_PATH
ARG ROOT_TASK_LIB

# Copy artifacts from previous stages
COPY --from=kernel-builder /build/kernel/build/kernel.elf /artifacts/kernel.elf
COPY --from=elfloader-builder /build/runtime/elfloader/target/aarch64-unknown-none/release/libkaal_elfloader.a /artifacts/elfloader.a
COPY --from=roottask-linker /artifacts/root-task.elf /artifacts/root-task.elf
COPY --from=builder-tool /build/runtime/elfloader-builder/target/release/kaal-elfloader-builder /usr/local/bin/

WORKDIR /build

# Display artifact information
RUN echo "═══════════════════════════════════════════════════════════" && \
    echo "  Build Artifacts" && \
    echo "═══════════════════════════════════════════════════════════" && \
    echo "" && \
    echo "Kernel:" && file /artifacts/kernel.elf && ls -lh /artifacts/kernel.elf && \
    echo "" && \
    echo "Elfloader:" && file /artifacts/elfloader.a && ls -lh /artifacts/elfloader.a && \
    echo "" && \
    echo "Root Task (${PROJECT_PATH}):" && file /artifacts/root-task.elf && ls -lh /artifacts/root-task.elf && \
    echo "" && \
    echo "═══════════════════════════════════════════════════════════"

# Copy linker script
COPY tools/bootimage.ld /build/bootimage.ld

# Create bootable image by linking elfloader with embedded kernel and root task
RUN mkdir -p /output /build/link && \
    cd /build/link && \
    ar x /artifacts/elfloader.a && \
    ls -la *.o && \
    aarch64-linux-gnu-objcopy -I binary -O elf64-littleaarch64 -B aarch64 \
        --rename-section .data=.kernel_elf,alloc,load,readonly,data,contents \
        /artifacts/kernel.elf kernel_embed.o && \
    aarch64-linux-gnu-objcopy -I binary -O elf64-littleaarch64 -B aarch64 \
        --rename-section .data=.roottask_data,alloc,load,readonly,data,contents \
        /artifacts/root-task.elf roottask_embed.o && \
    aarch64-linux-gnu-ld -T /build/bootimage.ld -o /output/bootimage.elf \
        $(find . -name '*.o' ! -name 'kernel_embed.o' ! -name 'roottask_embed.o') \
        kernel_embed.o roottask_embed.o && \
    echo "✓ Bootable image created with elfloader + kernel + root task"

# Create build information file
RUN echo "Bootable Image Build Information" > /output/build-info.txt && \
    echo "=================================" >> /output/build-info.txt && \
    echo "" >> /output/build-info.txt && \
    echo "Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> /output/build-info.txt && \
    echo "Builder: Docker multi-stage build" >> /output/build-info.txt && \
    echo "Project: ${PROJECT_PATH}" >> /output/build-info.txt && \
    echo "" >> /output/build-info.txt && \
    echo "Components:" >> /output/build-info.txt && \
    echo "  Kernel: $(file /artifacts/kernel.elf | cut -d: -f2)" >> /output/build-info.txt && \
    echo "  Elfloader: $(file /artifacts/elfloader.a | cut -d: -f2)" >> /output/build-info.txt && \
    echo "  Root Task: $(file /artifacts/root-task.elf | cut -d: -f2)" >> /output/build-info.txt && \
    echo "" >> /output/build-info.txt && \
    echo "Platform: QEMU ARM virt (Cortex-A53)" >> /output/build-info.txt && \
    echo "Elfloader Load Address: 0x40100000" >> /output/build-info.txt && \
    echo "DTB Address: 0x40000000 - 0x40100000 (1MB)" >> /output/build-info.txt

# Verify output exists
RUN test -f /output/bootimage.elf || \
    (echo "ERROR: bootimage.elf not created!" && exit 1)

# ============================================================================
# Stage 8: QEMU Test Stage
# ============================================================================
FROM builder-base AS qemu-test

COPY --from=assembler /output/bootimage.elf /test/bootimage.elf

WORKDIR /test

# Run QEMU for 3 seconds and capture output
RUN echo "Testing bootimage in QEMU..." && \
    timeout 3s qemu-system-aarch64 \
        -machine virt,virtualization=on,highmem=off,secure=off \
        -cpu cortex-a53 \
        -m 512M \
        -nographic \
        -serial mon:stdio \
        -kernel bootimage.elf \
        > qemu-output.txt 2>&1 || true && \
    echo "═══════════════════════════════════════════════════════════" && \
    echo "  QEMU Test Output" && \
    echo "═══════════════════════════════════════════════════════════" && \
    cat qemu-output.txt && \
    echo "═══════════════════════════════════════════════════════════"

# ============================================================================
# Stage 9: Final Output Image
# ============================================================================
FROM assembler AS output

# This stage exists only to extract files from
# Use: docker create <image> and docker cp
# The bootimage.elf and build-info.txt are already in /output/
