#!/bin/bash
# KaaL Build System - Config-driven multi-platform build

set -e

PROJECT_ROOT="$(cd "$(dirname "$0")" && pwd)"
cd "$PROJECT_ROOT"

# =============================================================================
# Configuration Parser (TOML-lite for bash)
# =============================================================================

get_config() {
    local section="$1"
    local key="$2"
    local config_file="$PROJECT_ROOT/build-config.toml"

    # Parse TOML: find [section], then find key = "value" (BSD awk compatible)
    awk -v section="$section" -v key="$key" '
        /^\[/ {
            gsub(/^\[|\].*$/, "")
            current_section = $0
        }
        current_section == section && $0 ~ "^"key" " {
            # Extract value between quotes
            if (match($0, /"[^"]*"/)) {
                val = substr($0, RSTART+1, RLENGTH-2)
                print val
            }
        }
    ' "$config_file"
}

# Parse command-line arguments
PLATFORM=""
VERBOSE=0

while [[ $# -gt 0 ]]; do
    case $1 in
        --platform)
            PLATFORM="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--platform <platform>] [-v|--verbose]"
            exit 1
            ;;
    esac
done

# Get default platform if not specified
if [ -z "$PLATFORM" ]; then
    PLATFORM=$(get_config "build" "default_platform")
fi

echo "══════════════════════════════════════════════════════════"
echo "  KaaL Build System"
echo "  Platform: $PLATFORM"
echo "══════════════════════════════════════════════════════════"

# =============================================================================
# Load platform configuration
# =============================================================================

PLATFORM_NAME=$(get_config "platform.$PLATFORM" "name")
RAM_BASE=$(get_config "platform.$PLATFORM" "ram_base")
RAM_SIZE=$(get_config "platform.$PLATFORM" "ram_size")
DTB_OFFSET=$(get_config "platform.$PLATFORM" "dtb_offset")
ELFLOADER_OFFSET=$(get_config "platform.$PLATFORM" "elfloader_offset")
KERNEL_OFFSET=$(get_config "platform.$PLATFORM" "kernel_offset")
STACK_TOP_OFFSET=$(get_config "platform.$PLATFORM" "stack_top_offset")
KERNEL_STACK_SIZE=$(get_config "build" "kernel_stack_size")

# Calculate absolute addresses
ELFLOADER_ADDR=$(printf "0x%x" $((RAM_BASE + ELFLOADER_OFFSET)))
KERNEL_ADDR=$(printf "0x%x" $((RAM_BASE + KERNEL_OFFSET)))
STACK_TOP=$(printf "0x%x" $((RAM_BASE + STACK_TOP_OFFSET)))

[ $VERBOSE -eq 1 ] && {
    echo "Configuration:"
    echo "  RAM Base:       $RAM_BASE"
    echo "  Elfloader:      $ELFLOADER_ADDR"
    echo "  Kernel:         $KERNEL_ADDR"
    echo "  Stack Top:      $STACK_TOP"
    echo ""
}

# Load build configuration
BUILD_DIR="$PROJECT_ROOT/$(get_config "build" "output_dir")"
KERNEL_SOURCE_DIR="$(get_config "build" "kernel_source_dir")"
ELFLOADER_SOURCE_DIR="$(get_config "build" "elfloader_source_dir")"
ROOTTASK_SOURCE_DIR="$(get_config "build" "roottask_source_dir")"

mkdir -p "$BUILD_DIR"

# =============================================================================
# Generate kernel memory configuration
# =============================================================================

echo "Generating kernel memory configuration..."

# Load memory layout configuration
KERNEL_VIRT_BASE=$(get_config "platform.$PLATFORM" "kernel_virt_base")
USER_VIRT_START=$(get_config "platform.$PLATFORM" "user_virt_start")
USER_VIRT_MAX=$(get_config "platform.$PLATFORM" "user_virt_max")
PAGE_SIZE=$(get_config "platform.$PLATFORM" "page_size")
HEAP_SIZE=$(get_config "platform.$PLATFORM" "heap_size" "0x100000")
MAX_FRAMES=$(get_config "platform.$PLATFORM" "max_physical_frames" "262144")

LARGE_PAGE_SIZE=$(get_config "platform.$PLATFORM" "large_page_size")
HUGE_PAGE_SIZE=$(get_config "platform.$PLATFORM" "huge_page_size")

# Load device addresses
UART0_BASE=$(get_config "platform.$PLATFORM" "uart0_base")
UART1_BASE=$(get_config "platform.$PLATFORM" "uart1_base")
RTC_BASE=$(get_config "platform.$PLATFORM" "rtc_base")
TIMER_BASE=$(get_config "platform.$PLATFORM" "timer_base")

# Generate memory_config.rs
mkdir -p kernel/src/generated
cat > kernel/src/generated/memory_config.rs << MEMCONFIG
//! Platform-specific memory and device configuration
//!
//! This file is auto-generated by build.sh from build-config.toml
//! DO NOT EDIT MANUALLY

/// Page size (4KB)
pub const PAGE_SIZE: usize = $PAGE_SIZE;

/// Large page size (2MB)
pub const LARGE_PAGE_SIZE: usize = $LARGE_PAGE_SIZE;

/// Huge page size (1GB)
pub const HUGE_PAGE_SIZE: usize = $HUGE_PAGE_SIZE;

/// Page shift for 4KB pages (log2(4096) = 12)
pub const PAGE_SHIFT: usize = 12;

/// Large page shift for 2MB pages (log2(2MB) = 21)
pub const LARGE_PAGE_SHIFT: usize = 21;

/// Huge page shift for 1GB pages (log2(1GB) = 30)
pub const HUGE_PAGE_SHIFT: usize = 30;

/// Kernel virtual address space base
pub const KERNEL_BASE: usize = $KERNEL_VIRT_BASE;

/// User virtual address space start
pub const USER_VIRT_START: u64 = $USER_VIRT_START;

/// User virtual address space maximum
pub const USER_MAX: usize = $USER_VIRT_MAX;

/// Kernel heap size
pub const HEAP_SIZE: usize = $HEAP_SIZE;

/// Maximum physical frames (for frame allocator)
pub const MAX_PHYSICAL_FRAMES: usize = $MAX_FRAMES;

/// RAM base address
pub const RAM_BASE: u64 = $RAM_BASE;

/// RAM size
pub const RAM_SIZE: u64 = $RAM_SIZE;

// =============================================================================
// Device MMIO Addresses
// =============================================================================

/// PL011 UART0 base address
pub const UART0_BASE: u64 = $UART0_BASE;

/// PL011 UART1 base address
pub const UART1_BASE: u64 = $UART1_BASE;

/// ARM PL031 RTC base address
pub const RTC_BASE: u64 = $RTC_BASE;

/// ARM Generic Timer base address
pub const TIMER_BASE: u64 = $TIMER_BASE;

// =============================================================================
// Device IDs for syscalls
// =============================================================================

/// Device ID for UART0
pub const DEVICE_UART0: u64 = 0;

/// Device ID for UART1
pub const DEVICE_UART1: u64 = 1;

/// Device ID for RTC
pub const DEVICE_RTC: u64 = 2;

/// Device ID for Timer
pub const DEVICE_TIMER: u64 = 3;
MEMCONFIG

[ $VERBOSE -eq 1 ] && {
    echo "Memory Configuration:"
    echo "  Kernel Base:    $KERNEL_VIRT_BASE"
    echo "  User Max:       $USER_VIRT_MAX"
    echo "  Page Size:      $PAGE_SIZE"
    echo ""
}

# =============================================================================
# Generate kernel linker script
# =============================================================================

echo "Generating kernel linker script..."
rm -f kernel/kernel.ld
cat > kernel/kernel.ld << KERNELLD
OUTPUT_FORMAT("elf64-littleaarch64")
OUTPUT_ARCH(aarch64)
ENTRY(_start)

SECTIONS
{
    . = $KERNEL_ADDR;
    _kernel_start = .;

    .text : {
        KEEP(*(.text._start))
        *(.text .text.*)
    }

    .rodata : ALIGN(4096) { *(.rodata .rodata.*) }
    .data : ALIGN(4096) { *(.data .data.*) }

    .bss : ALIGN(4096) {
        __bss_start = .;
        *(.bss .bss.*)
        *(COMMON)
        __bss_end = .;
    }

    .stack (NOLOAD) : ALIGN(4096) {
        . = . + $KERNEL_STACK_SIZE;
        __stack_top = .;
    }

    _kernel_end = .;
}
KERNELLD

# =============================================================================
# Step 1: Build kernel
# =============================================================================

echo ""
echo "[1/4] Building kernel..."
cargo clean --manifest-path $KERNEL_SOURCE_DIR/Cargo.toml 2>&1 | tail -1
RUSTFLAGS="-C link-arg=-T$PROJECT_ROOT/$KERNEL_SOURCE_DIR/kernel.ld" \
cargo build \
    --manifest-path $KERNEL_SOURCE_DIR/Cargo.toml \
    --release \
    --target aarch64-unknown-none \
    -Z build-std=core,alloc 2>&1 | grep -E "(Compiling|Finished|error)" || true

KERNEL_ELF="$KERNEL_SOURCE_DIR/target/aarch64-unknown-none/release/kaal-kernel"
[ -f "$KERNEL_ELF" ] || { echo "ERROR: Kernel not built"; exit 1; }
echo "✓ Kernel: $(ls -lh $KERNEL_ELF | awk '{print $5}')"

# =============================================================================
# Step 2: Build root task
# =============================================================================

echo ""
echo "[2/4] Building root task..."
if [ -d "$ROOTTASK_SOURCE_DIR" ]; then
    KAAL_PLATFORM=$PLATFORM cargo build \
        --manifest-path $ROOTTASK_SOURCE_DIR/Cargo.toml \
        --release \
        --target aarch64-unknown-none \
        -Z build-std=core 2>&1 | grep -E "(Compiling|Finished|error)" || true
    ROOTTASK_ELF="$ROOTTASK_SOURCE_DIR/target/aarch64-unknown-none/release/root-task"
else
    touch "$BUILD_DIR/roottask.bin"
    ROOTTASK_ELF="$BUILD_DIR/roottask.bin"
fi
[ -f "$ROOTTASK_ELF" ] || { echo "ERROR: Root task not built"; exit 1; }
echo "✓ Root task: $(ls -lh $ROOTTASK_ELF | awk '{print $5}')"

# =============================================================================
# Step 3: Create embeddable objects
# =============================================================================

echo ""
echo "[3/4] Creating embeddable objects..."
llvm-objcopy -I binary -O elf64-littleaarch64 \
    --rename-section .data=.kernel_elf \
    "$KERNEL_ELF" "$BUILD_DIR/kernel.o"
llvm-objcopy -I binary -O elf64-littleaarch64 \
    --rename-section .data=.roottask_data \
    "$ROOTTASK_ELF" "$BUILD_DIR/roottask.o"
echo "✓ kernel.o: $(ls -lh $BUILD_DIR/kernel.o | awk '{print $5}')"
echo "✓ roottask.o: $(ls -lh $BUILD_DIR/roottask.o | awk '{print $5}')"

# =============================================================================
# Step 4: Build elfloader
# =============================================================================

echo ""
echo "[4/4] Building elfloader..."

# Delete old linker script and generate new one
rm -f $ELFLOADER_SOURCE_DIR/linker.ld
cat > $ELFLOADER_SOURCE_DIR/linker.ld << ELFLD
OUTPUT_FORMAT("elf64-littleaarch64")
OUTPUT_ARCH(aarch64)
ENTRY(_start)

INPUT($BUILD_DIR/kernel.o)
INPUT($BUILD_DIR/roottask.o)

SECTIONS
{
    . = $ELFLOADER_ADDR;
    .text : { *(.text._start) *(.text .text.*) }
    .rodata : { *(.rodata .rodata.*) }

    .kernel_elf ALIGN(4096) : {
        __kernel_image_start = .;
        KEEP(*(.kernel_elf))
        __kernel_image_end = .;
    }

    .roottask_data ALIGN(4096) : {
        __user_image_start = .;
        KEEP(*(.roottask_data))
        __user_image_end = .;
    }

    .data : { *(.data .data.*) }
    .bss : {
        __bss_start = .;
        *(.bss .bss.*)
        *(COMMON)
        __bss_end = .;
    }

    __elfloader_end = .;
    . = $STACK_TOP;
    __stack_top = .;
}
ELFLD

# Force elfloader rebuild by cleaning
cd $ELFLOADER_SOURCE_DIR
cargo clean 2>&1 | tail -1

# Get elfloader target json
ELFLOADER_TARGET_JSON=$(get_config "platform.$PLATFORM" "elfloader_target_json")

# Build elfloader (only pass feature if it exists)
CARGO_FEATURES=""
if cargo read-manifest --manifest-path "$PROJECT_ROOT/$ELFLOADER_SOURCE_DIR/Cargo.toml" 2>/dev/null | grep -q "platform-$PLATFORM"; then
    CARGO_FEATURES="--features platform-$PLATFORM"
fi

RUSTFLAGS="-C link-arg=-T$PROJECT_ROOT/$ELFLOADER_SOURCE_DIR/linker.ld" \
cargo build \
    --target "$PROJECT_ROOT/$ELFLOADER_SOURCE_DIR/$ELFLOADER_TARGET_JSON" \
    --bin elfloader \
    --release \
    $CARGO_FEATURES \
    -Z build-std=core,alloc 2>&1 | grep -E "(Compiling|Finished|error)" | head -20

BOOTIMAGE="target/aarch64-unknown-none-elf/release/elfloader"
[ -f "$BOOTIMAGE" ] || { echo "ERROR: Bootimage not built"; exit 1; }

# Get QEMU launch parameters
QEMU_MACHINE=$(get_config "platform.$PLATFORM" "qemu_machine")
QEMU_CPU=$(get_config "platform.$PLATFORM" "qemu_cpu")
QEMU_MEMORY=$(get_config "platform.$PLATFORM" "qemu_memory")

echo ""
echo "══════════════════════════════════════════════════════════"
echo "  ✓ BUILD COMPLETE"
echo "══════════════════════════════════════════════════════════"
echo ""
echo "Platform:  $PLATFORM_NAME"
echo "Bootimage: $PROJECT_ROOT/$ELFLOADER_SOURCE_DIR/$BOOTIMAGE"
ls -lh "$BOOTIMAGE"
echo ""
if [ -n "$QEMU_MACHINE" ]; then
    echo "Run: qemu-system-aarch64 -machine $QEMU_MACHINE -cpu $QEMU_CPU -m $QEMU_MEMORY -nographic -kernel $PROJECT_ROOT/$ELFLOADER_SOURCE_DIR/$BOOTIMAGE"
else
    echo "Deploy bootimage to target platform: $PLATFORM_NAME"
fi
echo ""
