â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  KaaL Build System (Modular Nushell)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Platform: QEMU virt (ARM64)
Target:   aarch64

ğŸ” Discovered 9 components from components.toml:
  [âœ“] system_init
      Type: service, Priority: 50, Caps: 3
  [âœ“] serial_driver
      Type: driver, Priority: 200, Caps: 3
  [âœ“] timer_driver
      Type: driver, Priority: 200, Caps: 3
  [âœ“] process_manager
      Type: service, Priority: 150, Caps: 4
  [ ] vfs_service
      Type: service, Priority: 100, Caps: 2
  [ ] ipc_producer
      Type: service, Priority: 60, Caps: 3
  [ ] ipc_consumer
      Type: service, Priority: 60, Caps: 3
  [ ] test_minimal
      Type: service, Priority: 50, Caps: 0
  [ ] shell
      Type: application, Priority: 50, Caps: 3

âœ“ Component manifest validation passed

Generating component linker scripts...
  Skipping serial_driver - not a Rust component
  Skipping timer_driver - not a Rust component
  Skipping process_manager - not a Rust component
  Skipping vfs_service - not a Rust component
  Skipping shell - not a Rust component

Building components...
  â†’ Building system_init...
  â†’ Building ipc_producer...
  â†’ Building ipc_consumer...
  â†’ Building test_minimal...
âœ“ Components built

Generating component registry...
âœ“ Generated registry with 9 components
Generating kernel memory configuration...

[1/4] Building kernel...
Generating kernel linker script...
     Removed 113 files, 112.1MiB total
âœ“ Kernel: 158.3 kB

[2/4] Building root-task...
Generating root-task memory configuration...
Generating root-task linker script...
âœ“ Root-task: 389.2 kB

[3/4] Creating embeddable objects...
âœ“ kernel.o: 158.9 kB
âœ“ roottask.o: 389.9 kB

[4/4] Building elfloader...
     Removed 291 files, 152.3MiB total

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âœ“ BUILD COMPLETE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Platform:  QEMU virt (ARM64)
Bootimage: runtime/elfloader/target/aarch64-unknown-none-elf/release/elfloader

âœ“ Final Image: 638.4 kB

Run in QEMU:
  qemu-system-aarch64 -machine virt -cpu cortex-a53 -m 128M -nographic -kernel runtime/elfloader/target/aarch64-unknown-none-elf/release/elfloader

ğŸ“¦ Autostart Components: 4
  â€¢ system_init (service, priority: 50)
  â€¢ serial_driver (driver, priority: 200)
  â€¢ timer_driver (driver, priority: 200)
  â€¢ process_manager (service, priority: 150)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸš€ LAUNCHING QEMU
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Machine: virt
CPU:     cortex-a53
Memory:  128M
Image:   runtime/elfloader/target/aarch64-unknown-none-elf/release/elfloader

[33mPress Ctrl+A then X to exit QEMU[0m

!@â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  KaaL Elfloader v0.1.0 - Rust Microkernel Boot Loader
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DTB address: 0x40000000
Device tree parsed successfully
Model: linux,dummy-virt
Memory region: 0x40000000 - 0x48000000 (128 MB)

Loading images...
Loading embedded images from ELF sections...
  Kernel: 0x40205000 - 0x4022ba80 (154 KB)
  User:   0x4022c000 - 0x4028b090 (380 KB)
ELF: entry=0x40400000, 4 program headers at offset 0x40
  LOAD segment 0: vaddr=0x40400000, filesz=0x81fc, memsz=0x81fc
  LOAD segment 1: vaddr=0x40409000, filesz=0x4908, memsz=0x4908
  LOAD segment 2: vaddr=0x4040e000, filesz=0x10, memsz=0x2e000
Kernel loaded at entry point: 0x40400000
ELF: entry=0x40100000, 4 program headers at offset 0x40
  LOAD segment 0: vaddr=0x40100000, filesz=0x5960, memsz=0x5960
  LOAD segment 1: vaddr=0x40106000, filesz=0x44818, memsz=0x44818
  LOAD segment 2: vaddr=0x4014b000, filesz=0x20, memsz=0x1088
Root task loaded at entry point: 0x40100000
Images loaded successfully!
Kernel entry: 0x40400000
Root task:  0x4022c000 - 0x4028b090
Root entry: 0x40100000
DTB info will be passed to kernel via function parameters
  DTB: 0x40000000 (size: 1048576)
Kernel entry: 0x40400000
User image: 0x4022c000 - 0x4028b090
User entry: 0x40100000

Setting up page tables...
Setting up identity map: 0x10000000 - 0x4028ba88
Page tables configured
TTBR0: 0x47ffc000

Skipping MMU setup - kernel will handle it

Jumping to KaaL kernel at 0x40400000...
  Passing root task info:
    user_img: 0x4022c000 - 0x4028b090
    user_entry: 0x40100000
    pv_offset: 0x0
    dtb: 0x40000000 (size: 1048576)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  KaaL Rust Microkernel v0.1.0
  Chapter 1: Bare Metal Boot & Early Init
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Boot parameters:
  DTB:         0x40000000 (size: 1048576 bytes)
  Root task:   0x4022c000 - 0x4028b090
  Entry:       0x40100000
  PV offset:   0x0

[boot] Boot info initialized and stored globally
Parsing device tree...
DTB parse: reading header at 0x40000000
DTB magic: 0xd00dfeed (expected 0xd00dfeed)
DTB magic OK
Parsing DTB structure at 0x40000040
  [1] Token 0x1 at offset 0x0
  [2] Token 0x3 at offset 0x8
    -> Prop 'interrupt-parent' (len=4)
  [3] Token 0x3 at offset 0x18
    -> Prop 'dma-coherent' (len=0)
  [4] Token 0x3 at offset 0x24
    -> Prop 'model' (len=17)
  Found model: 'linux,dummy-virt'
  [5] Token 0x3 at offset 0x44
    -> Prop '#size-cells' (len=4)
  [6] Token 0x3 at offset 0x54
    -> Prop '#address-cells' (len=4)
  [7] Token 0x3 at offset 0x64
    -> Prop 'compatible' (len=17)
  [8] Token 0x1 at offset 0x84
  [9] Token 0x3 at offset 0x90
    -> Prop 'migrate' (len=4)
  [10] Token 0x3 at offset 0xa0
    -> Prop 'cpu_on' (len=4)
  [11] Token 0x3 at offset 0xb0
    -> Prop 'cpu_off' (len=4)
  [12] Token 0x3 at offset 0xc0
    -> Prop 'cpu_suspend' (len=4)
  [13] Token 0x3 at offset 0xd0
    -> Prop 'method' (len=4)
  [14] Token 0x3 at offset 0xe0
    -> Prop 'compatible' (len=35)
  [15] Token 0x2 at offset 0x110
  [16] Token 0x1 at offset 0x114
    -> Entering memory node: 'memory@40000000'
  [17] Token 0x3 at offset 0x128
    -> Prop 'reg' (len=16)
    -> Reading memory reg property (len=16)
    -> Got start: 0x40000000
    -> Got size: 0x8000000
  Found memory: 0x40000000 - 0x48000000
  Found all required info, stopping parse
Device tree parsed successfully:
  Model:       linux,dummy-virt
  Memory:      0x40000000 - 0x48000000 (128 MB)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 1: COMPLETE âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 2: Memory Management
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[memory] Initializing memory subsystem
  RAM:    0x40000000 - 0x48000000 (128MB)
  Kernel: 0x40400000 - 0x4043c000 (240KB)
  Frames: 31684/32768 free (123MB usable)

[test] Testing frame allocator...
  Allocated frame: PFN(263228) @ 0x4043c000
  Allocated frame: PFN(263229) @ 0x4043d000
  Deallocated both frames
  Final stats: 31684/32768 frames free
[memory] Setting up page tables and MMU...
  Mapping DTB: 0x40000000 - 0x40400000
  Mapping kernel: 0x40400000 - 0x4043c000
  Mapping stack/heap region: 0x4043c000 - 0x48000000
  Mapping UART device: 0x9000000
  Root page table at: 0x4043c000
[exception] Installing exception vector table at 0x0000000040400800
[exception] Exception handlers installed
  Enabling MMU...
  MMU enabled: true
  âœ“ MMU enabled successfully with virtual memory!
[memory] No kernel heap (seL4 design: static allocation only)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 2: COMPLETE âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 3: Exception Handling & Syscalls
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 3: Phase 1 COMPLETE âœ“ (Exception vectors)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[info] Exception handling verified:
  âœ“ Trap frame saves/restores all 36 registers
  âœ“ ESR/FAR decoding for fault analysis
  âœ“ Data abort detection (EC 0x25)
  âœ“ Syscall detection (EC 0x15)
  âœ“ Context switching infrastructure ready

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 3: COMPLETE âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Kernel initialization complete!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Scheduler Initialization
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[scheduler] Initialized with idle thread at 0x40442000

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 7: Root Task & Boot Protocol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Creating root task:
  Root task image: 0x4022c000 - 0x4028b090 (380 KB)
  Entry point:     0x40100000
  User page table: 0x40443000
  Mapping kernel regions into user PT (EL1-only):
    Kernel: 0x40400000 - 0x4043c000
    Kernel data: 0x4043c000 - 0x48000000
    UART: 0x9000000
  âœ“ Kernel regions mapped
  ELF header: 4 program headers at offset 0x40
  LOAD segment 0:
    vaddr:  0x40100000
    offset: 0x10000
    filesz: 0x5960 (22880 bytes)
    memsz:  0x5960 (22880 bytes)
    flags:  0x5 (R-X)
    Mapping virt 0x40100000 â†’ phys 0x4023c000 (end: 0x40106000)
      Mapping page 0 at virt=0x40100000 phys=0x4023c000
      Mapping page 1 at virt=0x40101000 phys=0x4023d000
      Mapping page 2 at virt=0x40102000 phys=0x4023e000
      Mapping page 3 at virt=0x40103000 phys=0x4023f000
      Mapping page 4 at virt=0x40104000 phys=0x40240000
      Mapping page 5 at virt=0x40105000 phys=0x40241000
    Mapped 6 pages (24 KB)
  LOAD segment 1:
    vaddr:  0x40106000
    offset: 0x16000
    filesz: 0x44818 (280600 bytes)
    memsz:  0x44818 (280600 bytes)
    flags:  0x4 (R--)
    Mapping virt 0x40106000 â†’ phys 0x40242000 (end: 0x4014b000)
      Mapping page 0 at virt=0x40106000 phys=0x40242000
      Mapping page 1 at virt=0x40107000 phys=0x40243000
      Mapping page 2 at virt=0x40108000 phys=0x40244000
      Mapping page 3 at virt=0x40109000 phys=0x40245000
      Mapping page 4 at virt=0x4010a000 phys=0x40246000
      Mapping page 5 at virt=0x4010b000 phys=0x40247000
      Mapping page 6 at virt=0x4010c000 phys=0x40248000
      Mapping page 7 at virt=0x4010d000 phys=0x40249000
      Mapping page 8 at virt=0x4010e000 phys=0x4024a000
      Mapping page 9 at virt=0x4010f000 phys=0x4024b000
      Mapping page 10 at virt=0x40110000 phys=0x4024c000
      Mapping page 11 at virt=0x40111000 phys=0x4024d000
      Mapping page 12 at virt=0x40112000 phys=0x4024e000
      Mapping page 13 at virt=0x40113000 phys=0x4024f000
      Mapping page 14 at virt=0x40114000 phys=0x40250000
      Mapping page 15 at virt=0x40115000 phys=0x40251000
      Mapping page 16 at virt=0x40116000 phys=0x40252000
      Mapping page 17 at virt=0x40117000 phys=0x40253000
      Mapping page 18 at virt=0x40118000 phys=0x40254000
      Mapping page 19 at virt=0x40119000 phys=0x40255000
      Mapping page 20 at virt=0x4011a000 phys=0x40256000
      Mapping page 21 at virt=0x4011b000 phys=0x40257000
      Mapping page 22 at virt=0x4011c000 phys=0x40258000
      Mapping page 23 at virt=0x4011d000 phys=0x40259000
      Mapping page 24 at virt=0x4011e000 phys=0x4025a000
      Mapping page 25 at virt=0x4011f000 phys=0x4025b000
      Mapping page 26 at virt=0x40120000 phys=0x4025c000
      Mapping page 27 at virt=0x40121000 phys=0x4025d000
      Mapping page 28 at virt=0x40122000 phys=0x4025e000
      Mapping page 29 at virt=0x40123000 phys=0x4025f000
      Mapping page 30 at virt=0x40124000 phys=0x40260000
      Mapping page 31 at virt=0x40125000 phys=0x40261000
      Mapping page 32 at virt=0x40126000 phys=0x40262000
      Mapping page 33 at virt=0x40127000 phys=0x40263000
      Mapping page 34 at virt=0x40128000 phys=0x40264000
      Mapping page 35 at virt=0x40129000 phys=0x40265000
      Mapping page 36 at virt=0x4012a000 phys=0x40266000
      Mapping page 37 at virt=0x4012b000 phys=0x40267000
      Mapping page 38 at virt=0x4012c000 phys=0x40268000
      Mapping page 39 at virt=0x4012d000 phys=0x40269000
      Mapping page 40 at virt=0x4012e000 phys=0x4026a000
      Mapping page 41 at virt=0x4012f000 phys=0x4026b000
      Mapping page 42 at virt=0x40130000 phys=0x4026c000
      Mapping page 43 at virt=0x40131000 phys=0x4026d000
      Mapping page 44 at virt=0x40132000 phys=0x4026e000
      Mapping page 45 at virt=0x40133000 phys=0x4026f000
      Mapping page 46 at virt=0x40134000 phys=0x40270000
      Mapping page 47 at virt=0x40135000 phys=0x40271000
      Mapping page 48 at virt=0x40136000 phys=0x40272000
      Mapping page 49 at virt=0x40137000 phys=0x40273000
      Mapping page 50 at virt=0x40138000 phys=0x40274000
      Mapping page 51 at virt=0x40139000 phys=0x40275000
      Mapping page 52 at virt=0x4013a000 phys=0x40276000
      Mapping page 53 at virt=0x4013b000 phys=0x40277000
      Mapping page 54 at virt=0x4013c000 phys=0x40278000
      Mapping page 55 at virt=0x4013d000 phys=0x40279000
      Mapping page 56 at virt=0x4013e000 phys=0x4027a000
      Mapping page 57 at virt=0x4013f000 phys=0x4027b000
      Mapping page 58 at virt=0x40140000 phys=0x4027c000
      Mapping page 59 at virt=0x40141000 phys=0x4027d000
      Mapping page 60 at virt=0x40142000 phys=0x4027e000
      Mapping page 61 at virt=0x40143000 phys=0x4027f000
      Mapping page 62 at virt=0x40144000 phys=0x40280000
      Mapping page 63 at virt=0x40145000 phys=0x40281000
      Mapping page 64 at virt=0x40146000 phys=0x40282000
      Mapping page 65 at virt=0x40147000 phys=0x40283000
      Mapping page 66 at virt=0x40148000 phys=0x40284000
      Mapping page 67 at virt=0x40149000 phys=0x40285000
      Mapping page 68 at virt=0x4014a000 phys=0x40286000
    Mapped 69 pages (276 KB)
  LOAD segment 2:
    vaddr:  0x4014b000
    offset: 0x5b000
    filesz: 0x20 (32 bytes)
    memsz:  0x1088 (4232 bytes)
    flags:  0x6 (RW-)
    Mapping virt 0x4014b000 â†’ phys 0x40287000 (end: 0x4014d000)
      Mapping page 0 at virt=0x4014b000 phys=0x40287000
      Mapping page 1 at virt=0x4014c000 phys=0x40288000
    Mapped 2 pages (8 KB)
  Total: 77 pages mapped for all LOAD segments
  Mapping stack: 0x400bf000 - 0x400ff000
  Mapping heap: 0x2000000 - 0x2040000 (256 KB)
  Entry point:     0x40100000
  Stack:           0x400bf000 - 0x400ff000 (256 KB)
  Heap:            0x2000000 - 0x2040000 (256 KB)
  âœ“ Root task ready for EL0 transition

[root_task] Creating boot info for runtime services...
[boot_info] Created userspace boot info:
  Devices:  4 regions
  Untyped:  1 regions
  RAM size: 128 MB
  Boot info phys:  0x4044b000
  Boot info virt:  0x7ffff000
  Boot info size:  11088 bytes
  âœ“ Boot info mapped for userspace
  Creating CNode for capability space...
  CNode:           0x4044d000 (256 slots)
  Creating root TCB...
  Root TCB frame:  0x4044e000
  Initializing TCB...
  Writing TCB...
  Setting state to Running...
  Setting saved_ttbr0...
  Registering with scheduler...
  Root TCB:        0x4044e000 âœ“

[root_task] Transitioning to EL0...
  Entry:    0x40100000
  Stack:    0x400ff000
  TTBR0:    0x40443000
  About to call transition_to_el0...
  VBAR_EL1: 0x40400800
  CurrentEL before: 0x4
  Cache flushed
  First instruction at phys 0x4023c000: 0xa9ba7bfd
  Expected: 0xa9ba7bfd (stp x29, x30, [sp, #-0x60]!)
  User PT is at phys 0x40443000

    $$â•²   $$â•²                    $$â•²       
    $$ â”‚ $$  â”‚                   $$ â”‚      
    $$ â”‚$$  â•± $$$$$$â•²   $$$$$$â•²  $$ â”‚      
    $$$$$  â•±  â•²____$$â•²  â•²____$$â•² $$ â”‚      
    $$  $$<   $$$$$$$ â”‚ $$$$$$$ â”‚$$ â”‚      
    $$ â”‚â•²$$â•² $$  __$$ â”‚$$  __$$ â”‚$$ â”‚      
    $$ â”‚ â•²$$â•²â•²$$$$$$$ â”‚â•²$$$$$$$ â”‚$$$$$$$$â•² 
    â•²__â”‚  â•²__â”‚â•²_______â”‚ â•²_______â”‚â•²________â”‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  KaaL Root Task (EL0) v0.1.0
  Chapter 7: Root Task & Boot Protocol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Hello from userspace (EL0)!
[root_task] Syscalls working: sys_print functional

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 7: COMPLETE âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 1: Testing Capability Broker API
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Initializing Capability Broker...
  âœ“ Capability Broker initialized

[root_task] Test 1: Allocating memory via broker...
  âœ“ Allocated 4096 bytes at: 0x000000004044f000
    Cap slot: 100

[root_task] Test 2: Requesting UART0 device via broker...
  âœ“ UART0 device allocated:
    MMIO base: 0x0000000009000000
    MMIO size: 4096 bytes
    IRQ cap: 101

[root_task] Test 3: Creating IPC endpoint via broker...
  âœ“ IPC endpoint created:
    Cap slot: 102
    Endpoint ID: 0

[root_task] Test 4: Requesting multiple devices...
  â†’ Requesting RTC...
    âœ“ RTC MMIO: 0x000000000a000000
  â†’ Requesting Timer...
    âœ“ Timer MMIO: 0x000000000a003000

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 1: Capability Broker Tests Complete âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 2: Testing IPC Syscalls
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Test 1: IPC Send syscall
  â†’ Calling sys_send(endpoint=102, msg_ptr=0x1000, len=18)...
  âœ— sys_send returned error (-1)

[root_task] Test 2: IPC Recv syscall
  â†’ Calling sys_recv(endpoint=102, buf_ptr=0x2000, len=256)...
  âœ— sys_recv returned error (-1)

[root_task] Test 3: IPC Call syscall (RPC)
  â†’ Calling sys_call(endpoint=102, req_len=7, rep_len=256)...
  âœ“ sys_call returned 0 bytes in reply

[root_task] Test 4: IPC Reply syscall
  â†’ Calling sys_reply(reply_cap=200, msg_ptr=0x3000)...
  âœ“ sys_reply returned success (0)

[root_task] Test 5: Error handling (invalid params)
  â†’ Calling sys_send with invalid endpoint=9999...
  âœ“ Correctly returned error (-1) for invalid endpoint

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 2: IPC Syscall Tests Complete âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 2: Testing Notification Syscalls
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[notification] Test 1: Creating notification object...
  âœ“ Notification created at cap slot 101
[notification] Test 2: Polling empty notification...
  âœ“ Poll returned 0 (no signals)
[notification] Test 3: Signaling notification with badge 0x5...
  âœ“ Signal succeeded
[notification] Test 4: Polling signaled notification...
  âœ“ Poll returned 0x5 (correct badge)
[notification] Test 5: Polling again (should be cleared)...
  âœ“ Poll returned 0 (signals cleared)
[notification] Test 6: Testing badge coalescing...
  âœ“ Badge coalescing works (0x1 | 0x2 | 0x4 = 0x7)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Notification Tests: PASS âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 2: Testing Shared Memory IPC
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ipc] Test 1: Allocating shared memory for ring buffer...
  âœ“ Shared memory allocated at phys: 0x0000000040452000
[ipc] Test 2: Creating notification objects for signaling...
  âœ“ Consumer notification: cap_slot 102
  âœ“ Producer notification: cap_slot 103

[ipc] Test 3: Verifying notification-based signaling...
  â†’ Producer signals consumer (badge=0x1: data available)...
  âœ“ Consumer received signal: 0x1
  â†’ Consumer signals producer (badge=0x2: space available)...
  âœ“ Producer received signal: 0x2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Shared Memory IPC Infrastructure: VERIFIED âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ipc] Summary:
  âœ“ Shared memory allocation works
  âœ“ Notification creation works
  âœ“ Producerâ†’Consumer signaling works
  âœ“ Consumerâ†’Producer signaling works
  âœ“ Ready for process-level IPC implementation

[ipc] Note: Full process spawning with shared memory requires:
  1. Spawn sender and receiver as separate processes
  2. Map shared memory into both process address spaces
  3. Pass notification capabilities to both processes
  4. Initialize SharedRing in mapped shared memory


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 4: Component Loading & Spawning
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Component Registry:
  â†’ Total components: 9
  â†’ Autostart components: 4

[root_task] Spawning autostart components...
  â†’ Spawning system_init...
[loader] Spawning component: system_init, binary_data len=67360, contains: UNKNOWN
[loader] ELF for system_init:
  Entry: 0x0000000000200000
  Segments:
    [0] vaddr=0x0000000000200000 filesz=0x00000000000002cc memsz=0x00000000000002cc
    [1] vaddr=0x00000000002002d0 filesz=0x0000000000000337 memsz=0x0000000000000337
  Total range: 0x0000000000200000 - 0x0000000000200607
[loader] Mapping phys 0x0000000040455000 size=0x0000000000002000 for copying
[syscall] memory_map: phys=0x40455000, size=0x2000, perms=0x3
[syscall] memory_map: allocated virt range 0x80000000 - 0x80002000, mapping 2 pages
[syscall] memory_map: SUCCESS - returning virt=0x80000000
[loader] Mapped to virt 0x0000000080000000, will copy 67360 bytes from binary_data
[loader] Binary data first 4 bytes: 00000000464c457f
[loader] Copying segment 0: 716 bytes from src=0x0000000040117765 to dest=0x0000000080000000
[loader] Copying segment 1: 823 bytes from src=0x0000000040117a35 to dest=0x00000000800002d0
[loader] Entry point 0x0000000000200000: first instruction = 0x00000000940000b0
[loader] Unmapping virt 0x0000000080000000
[loader] Unmap complete
[loader] Calling sys_process_create with code_phys=0x0000000040455000, code_size=0x0000000000002000
[syscall] sys_process_create: entry=0x200000, stack=0x80000000, pt=0x4045b000, priority=50
[syscall] sys_process_create: code_phys=0x40455000, code_vaddr=0x200000, code_size=0x2000, stack_phys=0x40457000
[syscall] Mapping page 0: virt=0x200000 -> phys=0x40455000
[syscall] Mapping page 1: virt=0x201000 -> phys=0x40456000
[syscall] process_create: set priority 50 for component
[syscall] process_create: enqueuing TCB at 0x4045f000
[syscall] process_create: SUCCESS - PID=0x4045f000
[syscall] process_create: set TrapFrame - x1=0x4045f000, x2=0x4045b000, x3=0x4045c000
[loader] Inserting TCB cap: slot=200, tcb_phys=0x000000004045f000
[syscall] cap_insert_self: slot=200, type=4, obj=0x4045f000
[syscall] cap_insert_self: âœ“ inserted Tcb cap at slot 200 in caller's CSpace
    âœ“ system_init spawned (PID: 1078325248)
  â†’ Spawning serial_driver...
    âœ— Failed to spawn serial_driver: no binary
  â†’ Spawning timer_driver...
    âœ— Failed to spawn timer_driver: no binary
  â†’ Spawning process_manager...
    âœ— Failed to spawn process_manager: no binary

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Component Spawning: COMPLETE âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[root_task] Yielding to spawned components...
  Will jump to ELR=0x200000 with SP=0x80000000

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  System Init Component v0.1.0
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[system_init] Initializing...
[system_init] Component spawned successfully!
[system_init] Running in userspace (EL0)

[system_init] Starting initialization
[system_init] Creating notification for event handling...
[system_init] Notification created successfully
[system_init] TODO: Spawn IPC producer component
[system_init] TODO: Spawn IPC consumer component
[system_init] TODO: Initialize system services

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  System Init: Ready âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[system_init] Entering event loop (blocking on notifications)
[root_task] Back from components!
[root_task] Component switching working! âœ“

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chapter 9 Phase 5: Inter-Component IPC
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[phase5] Step 1: Initializing IPC Channel Broker...
  â†’ Broker is part of runtime IPC subsystem
  â†’ Manages channel establishment with kernel privileges
  â†’ Calling init_broker with IPC region...
[exception] Unhandled EL0 exception:
  EC: 0x24, ESR: 0x92000004
  ELR: 0x40104154, FAR: 0x6e55205d7265667b
Error: nu::shell::terminated_by_signal

  x External command was terminated by a signal
     ,-[/Users/amaterasu/Vibranium/kaal/build.nu:183:10]
 182 |         # Launch QEMU
 183 |         ^qemu-system-aarch64 -machine $platform_cfg.qemu_machine -cpu $platform_cfg.qemu_cpu -m $platform_cfg.qemu_memory -nographic -kernel $bootimage
     :          ^^^^^^^^^|^^^^^^^^^
     :                   `-- terminated by SIGKILL (9)
 184 |     }
     `----

