# Code Generation Module
# Generates platform-specific configuration files and linker scripts

use ../utils/mod.nu *
use ../config/mod.nu *

# Generate kernel memory configuration
export def "codegen memory-config" [platform_cfg: record] {
    print "Generating kernel memory configuration..."

    ensure dir kernel/src/generated

    let config = $"//! Platform-specific memory and device configuration
//!
//! This file is auto-generated by build.nu from build-config.toml
//! DO NOT EDIT MANUALLY

/// Page size \(4KB\)
pub const PAGE_SIZE: usize = ($platform_cfg.page_size);

/// Large page size \(2MB\)
pub const LARGE_PAGE_SIZE: usize = ($platform_cfg.large_page_size);

/// Huge page size \(1GB\)
pub const HUGE_PAGE_SIZE: usize = ($platform_cfg.huge_page_size);

/// Page shift for 4KB pages \(log2\(4096\) = 12\)
pub const PAGE_SHIFT: usize = 12;

/// Large page shift for 2MB pages \(log2\(2MB\) = 21\)
pub const LARGE_PAGE_SHIFT: usize = 21;

/// Huge page shift for 1GB pages \(log2\(1GB\) = 30\)
pub const HUGE_PAGE_SHIFT: usize = 30;

/// Kernel virtual address space base
pub const KERNEL_BASE: usize = ($platform_cfg.kernel_virt_base);

/// User virtual address space start
pub const USER_VIRT_START: u64 = ($platform_cfg.user_virt_start);

/// User virtual address space maximum
pub const USER_MAX: usize = ($platform_cfg.user_virt_max);

/// Kernel heap size
pub const HEAP_SIZE: usize = ($platform_cfg.heap_size);

/// Maximum physical frames \(for frame allocator\)
pub const MAX_PHYSICAL_FRAMES: usize = ($platform_cfg.max_physical_frames);

/// RAM base address
pub const RAM_BASE: u64 = ($platform_cfg.ram_base);

/// RAM size
pub const RAM_SIZE: u64 = ($platform_cfg.ram_size);

// =============================================================================
// Device MMIO Addresses
// =============================================================================

/// PL011 UART0 base address
pub const UART0_BASE: u64 = ($platform_cfg.uart0_base);

/// PL011 UART1 base address
pub const UART1_BASE: u64 = ($platform_cfg.uart1_base);

/// ARM PL031 RTC base address
pub const RTC_BASE: u64 = ($platform_cfg.rtc_base);

/// ARM Generic Timer base address
pub const TIMER_BASE: u64 = ($platform_cfg.timer_base);

// =============================================================================
// Device IDs for syscalls
// =============================================================================

/// Device ID for UART0
pub const DEVICE_UART0: u64 = 0;

/// Device ID for UART1
pub const DEVICE_UART1: u64 = 1;

/// Device ID for RTC
pub const DEVICE_RTC: u64 = 2;

/// Device ID for Timer
pub const DEVICE_TIMER: u64 = 3;
"

    $config | save --force kernel/src/generated/memory_config.rs
}

# Generate kernel linker script
export def "codegen kernel-linker" [kernel_addr: string, stack_size: string] {
    print "Generating kernel linker script..."

    let script = $"OUTPUT_FORMAT\("elf64-littleaarch64"\)
OUTPUT_ARCH\(aarch64\)
ENTRY\(_start\)

SECTIONS
{
    . = ($kernel_addr);
    _kernel_start = .;

    .text : {
        KEEP\(*\(.text._start\)\)
        *\(.text .text.*\)
    }

    .rodata : ALIGN\(4096\) { *\(.rodata .rodata.*\) }
    .data : ALIGN\(4096\) { *\(.data .data.*\) }

    .bss : ALIGN\(4096\) {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    .stack \(NOLOAD\) : ALIGN\(4096\) {
        . = . + ($stack_size);
        __stack_top = .;
    }

    _kernel_end = .;
}
"

    $script | save --force kernel/kernel.ld
}

# Generate elfloader linker script
export def "codegen elfloader-linker" [
    elfloader_addr: string,
    stack_top: string,
    build_dir: string
] {
    # Use absolute path for INPUT like build.sh does
    let abs_build_dir = ($env.PWD | path join $build_dir)

    let script = $"OUTPUT_FORMAT\("elf64-littleaarch64"\)
OUTPUT_ARCH\(aarch64\)
ENTRY\(_start\)

INPUT\(($abs_build_dir)/kernel.o\)
INPUT\(($abs_build_dir)/roottask.o\)

SECTIONS
{
    . = ($elfloader_addr);
    .text : { *\(.text._start\) *\(.text .text.*\) }
    .rodata : { *\(.rodata .rodata.*\) }

    .kernel_elf ALIGN\(4096\) : {
        __kernel_image_start = .;
        KEEP\(*\(.kernel_elf\)\)
        __kernel_image_end = .;
    }

    .roottask_data ALIGN\(4096\) : {
        __user_image_start = .;
        KEEP\(*\(.roottask_data\)\)
        __user_image_end = .;
    }

    .data : { *\(.data .data.*\) }
    .bss : {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    __elfloader_end = .;
    . = ($stack_top);
    __stack_top = .;
}
"

    $script | save --force runtime/elfloader/linker.ld
}

# Generate root-task linker script
export def "codegen roottask-linker" [platform_cfg: record, root_task_stack_size: string] {
    print "Generating root-task linker script..."

    let roottask_load_base = (config calc-addr $platform_cfg.ram_base $platform_cfg.roottask_offset)

    let script = $"/*
 * KaaL Root Task Linker Script \(ARM64\)
 * AUTO-GENERATED - DO NOT EDIT
 * Generated from build-config.toml
 */

ENTRY\(_start\)

SECTIONS
{
    /*
     * Placeholder load address for linker
     * Actual address determined by elfloader at runtime and passed via boot info
     */
    . = ($roottask_load_base);

    /* Text section \(code\) */
    .text : ALIGN\(($platform_cfg.page_size)\) {
        *\(.text._start\)    /* Entry point first */
        *\(.text .text.*\)   /* All other code */
    }

    /* Read-only data */
    .rodata : ALIGN\(($platform_cfg.page_size)\) {
        *\(.rodata .rodata.*\)
    }

    /* Data section */
    .data : ALIGN\(($platform_cfg.page_size)\) {
        *\(.data .data.*\)
    }

    /* BSS \(zero-initialized data\) */
    .bss : ALIGN\(($platform_cfg.page_size)\) {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    /* Stack */
    . = ALIGN\(($platform_cfg.page_size)\);
    __stack_start = .;
    . += ($root_task_stack_size);
    __stack_end = .;

    /* End marker */
    . = ALIGN\(($platform_cfg.page_size)\);
    __root_task_end = .;

    /* Discard unwanted sections */
    /DISCARD/ : {
        *\(.comment\)
        *\(.gnu*\)
        *\(.note*\)
        *\(.eh_frame*\)
    }
}
"

    $script | save --force runtime/root-task/root-task.ld
}

# Generate component registry from components.toml
export def "codegen component-registry" [] {
    print "Generating component registry..."

    let components_data = (config load-components)
    let components = ($components_data | get component)

    ensure dir runtime/root-task/src/generated

    # Generate component descriptors
    let descriptors = ($components | each { |comp|
        let caps = ($comp.capabilities | each { |cap| $"        \"($cap)\"" } | str join ",\n")
        let caps_array = if ($caps | is-empty) { "    &[]" } else { $"    &[\n($caps)\n    ]" }

        # Only include binary if it exists
        let binary_path = $"components/($comp.binary)/target/aarch64-unknown-none/release/($comp.binary)"
        let binary_exists = ($binary_path | path exists)
        let binary_data = if $binary_exists {
            let rel_path = $"../../../../($binary_path)"
            $"Some\(include_bytes!\(\"($rel_path)\"\)\)"
        } else {
            "None"
        }

        $"    ComponentDescriptor {
        name: \"($comp.name)\",
        binary: \"($comp.binary)\",
        component_type: ComponentType::($comp.type | str capitalize),
        priority: ($comp.priority),
        autostart: ($comp.autostart),
        capabilities: ($caps_array),
        binary_data: ($binary_data),
    }"
    } | str join ",\n")

    let comp_count = ($components | length)
    let registry_code = (
        "//! Component Registry\n" +
        "//!\n" +
        "//! This file is auto-generated by build.nu from components.toml\n" +
        "//! DO NOT EDIT MANUALLY\n\n" +
        "use crate::component_loader::{ComponentDescriptor, ComponentType};\n\n" +
        "/// All registered components\n" +
        "pub static COMPONENT_REGISTRY: &[ComponentDescriptor] = &[\n" +
        $descriptors + "\n" +
        "];\n\n" +
        "/// Get autostart components\n" +
        "pub fn get_autostart_components() -> impl Iterator<Item = &'static ComponentDescriptor> {\n" +
        "    COMPONENT_REGISTRY.iter().filter(|c| c.autostart)\n" +
        "}\n\n" +
        "/// Get component by name\n" +
        "pub fn get_component(name: &str) -> Option<&'static ComponentDescriptor> {\n" +
        "    COMPONENT_REGISTRY.iter().find(|c| c.name == name)\n" +
        "}\n\n" +
        "/// Total number of components\n" +
        $"pub const COMPONENT_COUNT: usize = ($comp_count);\n"
    )

    $registry_code | save --force runtime/root-task/src/generated/component_registry.rs
    print $"âœ“ Generated registry with ($comp_count) components"
}