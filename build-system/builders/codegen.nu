# Code Generation Module
# Generates platform-specific configuration files and linker scripts

use ../utils/mod.nu *
use ../config/mod.nu *

# Generate kernel memory configuration
export def "codegen memory-config" [platform_cfg: record] {
    print "Generating kernel memory configuration..."

    ensure dir kernel/src/generated

    # Create mod.rs to export memory_config
    let mod_rs = $"//! Generated platform-specific configuration
//!
//! This file is auto-generated by build.nu
//! DO NOT EDIT MANUALLY

pub mod memory_config;
"
    $mod_rs | save --force kernel/src/generated/mod.rs

    let config = $"//! Platform-specific memory and device configuration
//!
//! This file is auto-generated by build.nu from build-config.toml
//! DO NOT EDIT MANUALLY

/// Page size \(4KB\)
pub const PAGE_SIZE: usize = ($platform_cfg.page_size);

/// Large page size \(2MB\)
pub const LARGE_PAGE_SIZE: usize = ($platform_cfg.large_page_size);

/// Huge page size \(1GB\)
pub const HUGE_PAGE_SIZE: usize = ($platform_cfg.huge_page_size);

/// Page shift for 4KB pages \(log2\(4096\) = 12\)
pub const PAGE_SHIFT: usize = 12;

/// Large page shift for 2MB pages \(log2\(2MB\) = 21\)
pub const LARGE_PAGE_SHIFT: usize = 21;

/// Huge page shift for 1GB pages \(log2\(1GB\) = 30\)
pub const HUGE_PAGE_SHIFT: usize = 30;

/// Kernel virtual address space base
pub const KERNEL_BASE: usize = ($platform_cfg.kernel_virt_base);

/// User virtual address space start
pub const USER_VIRT_START: u64 = ($platform_cfg.user_virt_start);

/// User virtual address space maximum
pub const USER_MAX: usize = ($platform_cfg.user_virt_max);

/// IPC shared memory region start - reserved in each component address space
pub const IPC_VIRT_START: usize = ($platform_cfg.ipc_virt_start);

/// IPC shared memory region end - reserved in each component address space
pub const IPC_VIRT_END: usize = ($platform_cfg.ipc_virt_end);

/// Kernel heap size
pub const HEAP_SIZE: usize = ($platform_cfg.heap_size);

/// Maximum physical frames \(for frame allocator\)
pub const MAX_PHYSICAL_FRAMES: usize = ($platform_cfg.max_physical_frames);

/// RAM base address
pub const RAM_BASE: u64 = ($platform_cfg.ram_base);

/// RAM size
pub const RAM_SIZE: u64 = ($platform_cfg.ram_size);

// =============================================================================
// Device MMIO Addresses
// =============================================================================

/// PL011 UART0 base address
pub const UART0_BASE: u64 = ($platform_cfg.uart0_base);

/// PL011 UART1 base address
pub const UART1_BASE: u64 = ($platform_cfg.uart1_base);

/// ARM PL031 RTC base address
pub const RTC_BASE: u64 = ($platform_cfg.rtc_base);

/// ARM Generic Timer base address
pub const TIMER_BASE: u64 = ($platform_cfg.timer_base);

// =============================================================================
// Device IDs for syscalls
// =============================================================================

/// Device ID for UART0
pub const DEVICE_UART0: u64 = 0;

/// Device ID for UART1
pub const DEVICE_UART1: u64 = 1;

/// Device ID for RTC
pub const DEVICE_RTC: u64 = 2;

/// Device ID for Timer
pub const DEVICE_TIMER: u64 = 3;
"

    $config | save --force kernel/src/generated/memory_config.rs
}

# Generate root-task memory configuration
export def "codegen roottask-memory-config" [platform_cfg: record] {
    print "Generating root-task memory configuration..."

    ensure dir runtime/root-task/src/generated

    # Create mod.rs to export submodules (if not already exists from component-registry generation)
    let mod_rs = $"//! Generated platform-specific configuration for root-task
//!
//! This file is auto-generated by build.nu
//! DO NOT EDIT MANUALLY

pub mod component_registry;
pub mod memory_config;
"
    $mod_rs | save --force runtime/root-task/src/generated/mod.rs

    let config = $"//! Platform-specific memory configuration for root-task
//!
//! This file is auto-generated by build.nu from build-config.toml
//! DO NOT EDIT MANUALLY

/// IPC shared memory region start - reserved in each component address space
pub const IPC_VIRT_START: usize = ($platform_cfg.ipc_virt_start);

/// IPC shared memory region end - reserved in each component address space
pub const IPC_VIRT_END: usize = ($platform_cfg.ipc_virt_end);

/// Page size \(4KB\)
pub const PAGE_SIZE: usize = ($platform_cfg.page_size);

/// User virtual address space start
pub const USER_VIRT_START: usize = ($platform_cfg.user_virt_start);

/// User virtual address space maximum
pub const USER_VIRT_MAX: usize = ($platform_cfg.user_virt_max);
"

    $config | save --force runtime/root-task/src/generated/memory_config.rs
}

# Generate component registry for system_init
export def "codegen system-init-registry" [] {
    print "Generating system_init component registry..."

    ensure dir components/system-init/src/generated

    # Create mod.rs to export registry
    let mod_rs = $"//! Generated component registry for system_init
//!
//! This file is auto-generated by build.nu
//! DO NOT EDIT MANUALLY

pub mod registry;
"
    $mod_rs | save --force components/system-init/src/generated/mod.rs

    # Load components.toml
    let components_config = open components.toml

    # Get all components that have binaries (filter out non-Rust components and system_init itself)
    let all_components = $components_config.component | each { |comp|
        # Skip system_init (can't spawn itself!)
        if $comp.name == "system_init" {
            return
        }

        let cargo_toml = $"components/($comp.binary)/Cargo.toml"
        if ($cargo_toml | path exists) {
            # Check if this component should be spawned by system_init
            let spawned_by_system_init = ($comp.spawned_by? | default "") == "system_init"

            # Parse capabilities to bitmask
            let caps_bitmask = (capabilities_to_bitmask $comp.capabilities)

            {
                name: $comp.name,
                type: $comp.type,
                priority: $comp.priority,
                # Components with spawned_by="system_init" are autostart for system_init
                autostart: $spawned_by_system_init,
                capabilities_bitmask: $caps_bitmask,
                # Path is relative to components/system-init/src/generated/registry.rs
                # Need to go up 4 levels to project root, then into components/
                binary_path: $"../../../../components/($comp.binary)/target/aarch64-unknown-none/release/($comp.binary)"
            }
        }
    } | compact  # Remove nulls from non-Rust components and system_init

    # Generate component descriptors
    let descriptors = ($all_components | each { |comp|
        let macro_call = 'include_bytes!("' + $comp.binary_path + '")'
        [
            "    ComponentDescriptor {"
            $'        name: "($comp.name)",'
            $'        priority: ($comp.priority),'
            $'        autostart: ($comp.autostart),'
            $'        capabilities_bitmask: ($comp.capabilities_bitmask),'
            $'        binary_data: ($macro_call),'
            "    },"
        ] | str join "\n"
    } | str join "\n")

    # Generate registry code
    let registry_code = [
        "// Component registry for system_init"
        "//"
        "// This file is auto-generated by build.nu from components.toml"
        "// DO NOT EDIT MANUALLY"
        ""
        "/// Component descriptor with embedded binary"
        "pub struct ComponentDescriptor {"
        "    pub name: &'static str,"
        "    pub priority: u8,"
        "    pub autostart: bool,"
        "    pub capabilities_bitmask: u64,"
        "    pub binary_data: &'static [u8],"
        "}"
        ""
        "/// Component registry - all known components with embedded binaries"
        "pub const COMPONENT_REGISTRY: &[ComponentDescriptor] = &["
        $descriptors
        "];"
    ] | str join "\n"

    $registry_code | save --force components/system-init/src/generated/registry.rs
}

# Generate kernel linker script
export def "codegen kernel-linker" [kernel_addr: string, stack_size: string] {
    print "Generating kernel linker script..."

    let script = $"OUTPUT_FORMAT\("elf64-littleaarch64"\)
OUTPUT_ARCH\(aarch64\)
ENTRY\(_start\)

SECTIONS
{
    . = ($kernel_addr);
    _kernel_start = .;

    .text : {
        KEEP\(*\(.text._start\)\)
        *\(.text .text.*\)
    }

    .rodata : ALIGN\(4096\) { *\(.rodata .rodata.*\) }
    .data : ALIGN\(4096\) { *\(.data .data.*\) }

    .bss : ALIGN\(4096\) {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    .stack \(NOLOAD\) : ALIGN\(4096\) {
        . = . + ($stack_size);
        __stack_top = .;
    }

    _kernel_end = .;
}
"

    $script | save --force kernel/kernel.ld
}

# Generate elfloader linker script
export def "codegen elfloader-linker" [
    elfloader_addr: string,
    stack_top: string,
    build_dir: string
] {
    # Use absolute path for INPUT like build.sh does
    let abs_build_dir = ($env.PWD | path join $build_dir)

    let script = $"OUTPUT_FORMAT\("elf64-littleaarch64"\)
OUTPUT_ARCH\(aarch64\)
ENTRY\(_start\)

INPUT\(($abs_build_dir)/kernel.o\)
INPUT\(($abs_build_dir)/roottask.o\)

SECTIONS
{
    . = ($elfloader_addr);
    .text : { *\(.text._start\) *\(.text .text.*\) }
    .rodata : { *\(.rodata .rodata.*\) }

    .kernel_elf ALIGN\(4096\) : {
        __kernel_image_start = .;
        KEEP\(*\(.kernel_elf\)\)
        __kernel_image_end = .;
    }

    .roottask_data ALIGN\(4096\) : {
        __user_image_start = .;
        KEEP\(*\(.roottask_data\)\)
        __user_image_end = .;
    }

    .data : { *\(.data .data.*\) }
    .bss : {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    __elfloader_end = .;
    . = ($stack_top);
    __stack_top = .;
}
"

    $script | save --force runtime/elfloader/linker.ld
}

# Generate root-task linker script
export def "codegen roottask-linker" [platform_cfg: record, root_task_stack_size: string] {
    print "Generating root-task linker script..."

    let roottask_load_base = (config calc-addr $platform_cfg.ram_base $platform_cfg.roottask_offset)

    let script = $"/*
 * KaaL Root Task Linker Script \(ARM64\)
 * AUTO-GENERATED - DO NOT EDIT
 * Generated from build-config.toml
 */

ENTRY\(_start\)

SECTIONS
{
    /*
     * Placeholder load address for linker
     * Actual address determined by elfloader at runtime and passed via boot info
     */
    . = ($roottask_load_base);

    /* Text section \(code\) */
    .text : ALIGN\(($platform_cfg.page_size)\) {
        *\(.text._start\)    /* Entry point first */
        *\(.text .text.*\)   /* All other code */
    }

    /* Read-only data */
    .rodata : ALIGN\(($platform_cfg.page_size)\) {
        *\(.rodata .rodata.*\)
    }

    /* Data section */
    .data : ALIGN\(($platform_cfg.page_size)\) {
        *\(.data .data.*\)
    }

    /* BSS \(zero-initialized data\) */
    .bss : ALIGN\(($platform_cfg.page_size)\) {
        __bss_start = .;
        *\(.bss .bss.*\)
        *\(COMMON\)
        __bss_end = .;
    }

    /* Stack */
    . = ALIGN\(($platform_cfg.page_size)\);
    __stack_start = .;
    . += ($root_task_stack_size);
    __stack_end = .;

    /* End marker */
    . = ALIGN\(($platform_cfg.page_size)\);
    __root_task_end = .;

    /* Discard unwanted sections */
    /DISCARD/ : {
        *\(.comment\)
        *\(.gnu*\)
        *\(.note*\)
        *\(.eh_frame*\)
    }
}
"

    $script | save --force runtime/root-task/root-task.ld
}

# Generate component linker scripts
export def "codegen component-linkers" [
    --platform: string = ""  # Platform name from build-config.toml
] {
    print "Generating component linker scripts..."

    # Get all components
    let components_data = (config load-components)
    let components = ($components_data | get component)

    # Load build configuration
    let build_config = (open build-config.toml)

    # Determine platform and get its architecture
    let platform_name = if ($platform | is-empty) {
        $build_config.build.default_platform
    } else {
        $platform
    }

    let platform_config = ($build_config.platform | get $platform_name)
    let target_arch = $platform_config.arch

    # Platform-specific memory configuration
    let memory_config = if $target_arch == "aarch64" {
        { origin: "0x200000", length: "2M", align: "8" }
    } else if $target_arch == "x86_64" {
        { origin: "0x400000", length: "4M", align: "16" }
    } else if $target_arch == "riscv64" {
        { origin: "0x80200000", length: "2M", align: "8" }
    } else {
        # Default to ARM64 settings
        { origin: "0x200000", length: "2M", align: "8" }
    }

    # Add platform-specific discard sections
    let discard_sections = if $target_arch == "aarch64" {
        "    *(.ARM.exidx)
    *(.ARM.exidx.*)
    *(.ARM.extab)
    *(.ARM.extab.*)"
    } else if $target_arch == "x86_64" {
        "    *(.eh_frame)
    *(.eh_frame_hdr)"
    } else if $target_arch == "riscv64" {
        "    *(.riscv.attributes)"
    } else {
        ""
    }

    # Component linker script template (link.x format for rust-lld)
    let linker_script = (
        "/* Component linker script for " + $target_arch + " */\n" +
        "ENTRY(_start)\n\n" +
        "MEMORY\n" +
        "{\n" +
        "  /* Component memory space starts at " + $memory_config.origin + " */\n" +
        "  RAM : ORIGIN = " + $memory_config.origin + ", LENGTH = " + $memory_config.length + "\n" +
        "}\n\n" +
        "SECTIONS\n" +
        "{\n" +
        "  /* Code starts at " + $memory_config.origin + " */\n" +
        "  .text " + $memory_config.origin + " : AT(" + $memory_config.origin + ")\n" +
        "  {\n" +
        "    /* Ensure _start is placed first */\n" +
        "    KEEP(*(.text._start))\n" +
        "    KEEP(*(.text.entry))\n" +
        "    *(.text .text.*)\n" +
        "  } > RAM\n\n" +
        "  .rodata : ALIGN(" + $memory_config.align + ")\n" +
        "  {\n" +
        "    *(.rodata .rodata.*)\n" +
        "  } > RAM\n\n" +
        "  .data : ALIGN(" + $memory_config.align + ")\n" +
        "  {\n" +
        "    *(.data .data.*)\n" +
        "  } > RAM\n\n" +
        "  .bss : ALIGN(" + $memory_config.align + ")\n" +
        "  {\n" +
        "    *(.bss .bss.*)\n" +
        "    *(COMMON)\n" +
        "  } > RAM\n\n" +
        "  /* Discard unwanted sections */\n" +
        "  /DISCARD/ :\n" +
        "  {\n" +
        $discard_sections + "\n" +
        "    *(.comment)\n" +
        "    *(.debug*)\n" +
        "  }\n" +
        "}"
    )

    # Platform-specific target configuration
    let target_triple = if $target_arch == "aarch64" {
        "aarch64-unknown-none"
    } else if $target_arch == "x86_64" {
        "x86_64-unknown-none"
    } else if $target_arch == "riscv64" {
        "riscv64gc-unknown-none-elf"
    } else {
        "aarch64-unknown-none"
    }

    # Component cargo config template - use component.ld linker script
    let cargo_config = (
        "[target." + $target_triple + "]\n" +
        "rustflags = [\n" +
        '    "-C", "link-arg=-Tcomponent.ld",    # Use custom linker script' + "\n" +
        '    "-C", "relocation-model=static",  # Static relocation' + "\n" +
        "]\n\n" +
        "[build]\n" +
        'target = "' + $target_triple + '"'
    )

    # Generate for each component
    for comp in $components {
        let comp_dir = $"components/($comp.binary)"

        # Skip if component doesn't have Cargo.toml
        let cargo_toml = $"($comp_dir)/Cargo.toml"
        if not ($cargo_toml | path exists) {
            print $"  Skipping ($comp.name) - not a Rust component"
            continue
        }

        # Create .cargo directory if it doesn't exist
        ensure dir $"($comp_dir)/.cargo"

        # Write linker script as component.ld
        $linker_script | save --force $"($comp_dir)/component.ld"

        # Write cargo config
        $cargo_config | save --force $"($comp_dir)/.cargo/config.toml"
    }
}

# Parse capability string to bitmask
# Returns u64 bitmask based on capability name
def parse_capability [cap: string]: nothing -> int {
    let cap_lower = ($cap | str downcase)

    # Check for wildcard patterns first
    if ($cap_lower | str starts-with "ipc:") or ($cap_lower == "ipc" or $cap_lower == "ipc:*") {
        return 4
    }
    if ($cap_lower | str starts-with "memory:") or ($cap_lower == "memory") {
        return 1
    }
    if ($cap_lower | str starts-with "process:") or ($cap_lower == "process") {
        return 2
    }
    if ($cap_lower | str starts-with "caps:") or ($cap_lower == "caps") {
        return 8
    }
    if ($cap_lower | str starts-with "notification:") or ($cap_lower == "notification") {
        return 4
    }
    if ($cap_lower | str starts-with "endpoint:") or ($cap_lower == "endpoint") {
        return 4
    }
    if ($cap_lower | str starts-with "interrupt:") {
        # Interrupts are not part of core capabilities yet - ignore
        return 0
    }

    # Exact matches
    match $cap_lower {
        # Memory capabilities
        "memory" => 1

        # Process capabilities
        "process" => 2

        # IPC capabilities
        "ipc" => 4
        "notification" => 4
        "endpoint" => 4

        # Capability management
        "caps" => 8

        _ => {
            # Only warn for unknown patterns that don't look like device-specific
            if not ($cap_lower | str contains ":") {
                print $"Warning: Unknown capability '($cap)', defaulting to 0"
            }
            0
        }
    }
}

# Convert capability array to bitmask
def capabilities_to_bitmask [caps: list<string>]: nothing -> int {
    if ($caps | is-empty) {
        return 0
    }
    $caps | each { |cap| parse_capability $cap } | reduce --fold 0 { |it, acc| $acc | bits or $it }
}

# Generate component registry from components.toml
export def "codegen component-registry" [] {
    print "Generating component registry..."

    let components_data = (config load-components)
    let components = ($components_data | get component)

    ensure dir runtime/root-task/src/generated

    # Create mod.rs to export submodules (MUST be created before root-task builds)
    let mod_rs = $"//! Generated platform-specific configuration for root-task
//!
//! This file is auto-generated by build.nu
//! DO NOT EDIT MANUALLY

pub mod component_registry;
pub mod memory_config;
"
    $mod_rs | save --force runtime/root-task/src/generated/mod.rs

    # Generate component descriptors
    let descriptors = ($components | each { |comp|
        let caps = ($comp.capabilities | each { |cap| $"        \"($cap)\"" } | str join ",\n")
        let caps_array = if ($caps | is-empty) { "    &[]" } else { $"    &[\n($caps)\n    ]" }

        # Parse capabilities to bitmask
        let caps_bitmask = (capabilities_to_bitmask $comp.capabilities)

        # Only include binary if it exists
        let binary_path = $"components/($comp.binary)/target/aarch64-unknown-none/release/($comp.binary)"
        let binary_exists = ($binary_path | path exists)
        let binary_data = if $binary_exists {
            let rel_path = $"../../../../($binary_path)"
            $"Some\(include_bytes!\(\"($rel_path)\"\)\)"
        } else {
            "None"
        }

        $"    ComponentDescriptor {
        name: \"($comp.name)\",
        binary: \"($comp.binary)\",
        component_type: ComponentType::($comp.type | str capitalize),
        priority: ($comp.priority),
        autostart: ($comp.autostart),
        capabilities: ($caps_array),
        capabilities_bitmask: ($caps_bitmask),
        binary_data: ($binary_data),
    }"
    } | str join ",\n")

    let comp_count = ($components | length)
    let registry_code = (
        "//! Component Registry\n" +
        "//!\n" +
        "//! This file is auto-generated by build.nu from components.toml\n" +
        "//! DO NOT EDIT MANUALLY\n\n" +
        "use crate::component_loader::{ComponentDescriptor, ComponentType};\n\n" +
        "/// All registered components\n" +
        "pub static COMPONENT_REGISTRY: &[ComponentDescriptor] = &[\n" +
        $descriptors + "\n" +
        "];\n\n" +
        "/// Get autostart components\n" +
        "pub fn get_autostart_components() -> impl Iterator<Item = &'static ComponentDescriptor> {\n" +
        "    COMPONENT_REGISTRY.iter().filter(|c| c.autostart)\n" +
        "}\n\n" +
        "/// Get component by name\n" +
        "pub fn get_component(name: &str) -> Option<&'static ComponentDescriptor> {\n" +
        "    COMPONENT_REGISTRY.iter().find(|c| c.name == name)\n" +
        "}\n\n" +
        "/// Total number of components\n" +
        $"pub const COMPONENT_COUNT: usize = ($comp_count);\n"
    )

    $registry_code | save --force runtime/root-task/src/generated/component_registry.rs
    print $"✓ Generated root-task registry with ($comp_count) components"

    # Also generate system_init registry
    codegen system-init-registry
}