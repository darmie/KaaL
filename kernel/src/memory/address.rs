//! Physical and virtual address types
//!
//! This module provides type-safe wrappers for physical and virtual addresses
//! following Rust's newtype pattern to prevent mixing physical and virtual
//! addresses at compile time.
//!
//! # Design (seL4-inspired)
//! - PhysAddr: Physical memory addresses (hardware addresses)
//! - VirtAddr: Virtual memory addresses (software addresses)
//! - Page-aligned addresses for MMU operations
//! - Type safety prevents mixing physical and virtual addresses
//!
//! # Verification
//! - Some functions have formal verification with Verus
//! - Enabled with `--features verification`
//! - Zero runtime overhead (proofs erased during compilation)
//!
//! # Platform Configuration
//! - Memory layout constants are platform-specific and loaded from build-config.toml
//! - Generated at build time to support different target platforms (QEMU, RPi4, etc.)

use core::fmt;
use core::ops::{Add, AddAssign, Sub, SubAssign};

#[cfg(feature = "verification")]
use vstd::prelude::*;

// Import platform-specific memory configuration (generated by build.sh)
#[path = "../generated/memory_config.rs"]
mod memory_config;

pub use memory_config::{
    PAGE_SIZE, LARGE_PAGE_SIZE, HUGE_PAGE_SIZE,
    PAGE_SHIFT, LARGE_PAGE_SHIFT, HUGE_PAGE_SHIFT,
    KERNEL_BASE, USER_MAX,
};

/// Physical memory address
///
/// Represents a physical address in the system's address space.
/// Used for hardware addresses, DMA, and page frame numbers.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct PhysAddr(pub usize);

impl PhysAddr {
    /// Create a new physical address
    ///
    /// # Safety
    /// The caller must ensure the address is valid for the target system
    pub const fn new(addr: usize) -> Self {
        PhysAddr(addr)
    }

    /// Create a physical address from a u64
    pub const fn from_u64(addr: u64) -> Self {
        PhysAddr(addr as usize)
    }

    /// Get the address as a usize
    pub const fn as_usize(self) -> usize {
        self.0
    }

    /// Get the address as a u64
    pub const fn as_u64(self) -> u64 {
        self.0 as u64
    }

    /// Check if address is aligned to given alignment
    ///
    /// # Verification
    /// With `--features verification`, formally verified to return true iff
    /// address is evenly divisible by alignment.
    pub const fn is_aligned(self, align: usize) -> bool {
        self.0.is_multiple_of(align)
    }

    /// Align address down to the given alignment
    pub const fn align_down(self, align: usize) -> Self {
        PhysAddr(self.0 - (self.0 % align))
    }

    /// Align address up to the given alignment
    pub const fn align_up(self, align: usize) -> Self {
        PhysAddr((self.0 + align - 1) - ((self.0 + align - 1) % align))
    }

    /// Get the page frame number (PFN) for 4KB pages
    pub const fn page_number(self) -> usize {
        self.0 / PAGE_SIZE
    }

    /// Check if address is null
    pub const fn is_null(self) -> bool {
        self.0 == 0
    }
}

impl fmt::Display for PhysAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PhysAddr({:#x})", self.0)
    }
}

impl fmt::Debug for PhysAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PhysAddr({:#x})", self.0)
    }
}

impl Add<usize> for PhysAddr {
    type Output = PhysAddr;

    fn add(self, rhs: usize) -> PhysAddr {
        PhysAddr(self.0 + rhs)
    }
}

impl AddAssign<usize> for PhysAddr {
    fn add_assign(&mut self, rhs: usize) {
        self.0 += rhs;
    }
}

impl Sub<usize> for PhysAddr {
    type Output = PhysAddr;

    fn sub(self, rhs: usize) -> PhysAddr {
        PhysAddr(self.0 - rhs)
    }
}

impl SubAssign<usize> for PhysAddr {
    fn sub_assign(&mut self, rhs: usize) {
        self.0 -= rhs;
    }
}

impl Sub<PhysAddr> for PhysAddr {
    type Output = usize;

    fn sub(self, rhs: PhysAddr) -> usize {
        self.0 - rhs.0
    }
}

/// Virtual memory address
///
/// Represents a virtual address in a process's address space.
/// Used for pointers, page table entries, and virtual memory operations.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct VirtAddr(pub usize);

impl VirtAddr {
    /// Create a new virtual address
    pub const fn new(addr: usize) -> Self {
        VirtAddr(addr)
    }

    /// Create a virtual address from a u64
    pub const fn from_u64(addr: u64) -> Self {
        VirtAddr(addr as usize)
    }

    /// Create a virtual address from a pointer
    ///
    /// Note: This cannot be const because pointer-to-int casts are not allowed in const context
    pub fn from_ptr<T>(ptr: *const T) -> Self {
        VirtAddr(ptr as usize)
    }

    /// Get the address as a usize
    pub const fn as_usize(self) -> usize {
        self.0
    }

    /// Get the address as a u64
    pub const fn as_u64(self) -> u64 {
        self.0 as u64
    }

    /// Get the address as a pointer
    pub const fn as_ptr<T>(self) -> *const T {
        self.0 as *const T
    }

    /// Get the address as a mutable pointer
    pub const fn as_mut_ptr<T>(self) -> *mut T {
        self.0 as *mut T
    }

    /// Check if address is page-aligned (4KB)
    pub const fn is_aligned(self, align: usize) -> bool {
        self.0.is_multiple_of(align)
    }

    /// Align address down to the given alignment
    pub const fn align_down(self, align: usize) -> Self {
        VirtAddr(self.0 - (self.0 % align))
    }

    /// Align address up to the given alignment
    pub const fn align_up(self, align: usize) -> Self {
        VirtAddr((self.0 + align - 1) - ((self.0 + align - 1) % align))
    }

    /// Get the page number for 4KB pages
    pub const fn page_number(self) -> usize {
        self.0 / PAGE_SIZE
    }

    /// Check if address is null
    pub const fn is_null(self) -> bool {
        self.0 == 0
    }

    /// Check if address is in kernel space (ARM64)
    /// Kernel space: 0xFFFF000000000000 and above
    pub const fn is_kernel(self) -> bool {
        self.0 >= KERNEL_BASE
    }

    /// Check if address is in user space (ARM64)
    /// User space: below 0x0001000000000000
    pub const fn is_user(self) -> bool {
        self.0 < USER_MAX
    }
}

impl fmt::Display for VirtAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "VirtAddr({:#x})", self.0)
    }
}

impl fmt::Debug for VirtAddr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "VirtAddr({:#x})", self.0)
    }
}

impl Add<usize> for VirtAddr {
    type Output = VirtAddr;

    fn add(self, rhs: usize) -> VirtAddr {
        VirtAddr(self.0 + rhs)
    }
}

impl AddAssign<usize> for VirtAddr {
    fn add_assign(&mut self, rhs: usize) {
        self.0 += rhs;
    }
}

impl Sub<usize> for VirtAddr {
    type Output = VirtAddr;

    fn sub(self, rhs: usize) -> VirtAddr {
        VirtAddr(self.0 - rhs)
    }
}

impl SubAssign<usize> for VirtAddr {
    fn sub_assign(&mut self, rhs: usize) {
        self.0 -= rhs;
    }
}

impl Sub<VirtAddr> for VirtAddr {
    type Output = usize;

    fn sub(self, rhs: VirtAddr) -> usize {
        self.0 - rhs.0
    }
}

// Platform-specific memory constants are now imported from generated/memory_config.rs
// This allows the kernel to support different platforms (QEMU, RPi4, etc.)
// without hardcoding QEMU-specific values

/// Page frame number
///
/// Represents a physical page frame number (PFN).
/// Used for tracking physical memory pages.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PageFrameNumber(pub usize);

impl PageFrameNumber {
    /// Create a new page frame number
    pub const fn new(pfn: usize) -> Self {
        PageFrameNumber(pfn)
    }

    /// Create PFN from physical address
    pub const fn from_phys_addr(addr: PhysAddr) -> Self {
        PageFrameNumber(addr.page_number())
    }

    /// Get the physical address of this page frame
    pub const fn phys_addr(self) -> PhysAddr {
        PhysAddr(self.0 * PAGE_SIZE)
    }

    /// Get the PFN as usize
    pub const fn as_usize(self) -> usize {
        self.0
    }
}

impl fmt::Display for PageFrameNumber {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PFN({})", self.0)
    }
}

impl fmt::Debug for PageFrameNumber {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PFN({}) @ {:#x}", self.0, self.phys_addr().0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_phys_addr_alignment() {
        let addr = PhysAddr::new(0x1234);
        assert_eq!(addr.align_down(PAGE_SIZE), PhysAddr::new(0x1000));
        assert_eq!(addr.align_up(PAGE_SIZE), PhysAddr::new(0x2000));
    }

    #[test]
    fn test_virt_addr_kernel_user() {
        let user = VirtAddr::new(0x1000);
        let kernel = VirtAddr::new(KERNEL_BASE + 0x1000);

        assert!(user.is_user());
        assert!(!user.is_kernel());
        assert!(kernel.is_kernel());
        assert!(!kernel.is_user());
    }

    #[test]
    fn test_page_frame_number() {
        let addr = PhysAddr::new(0x40400000);
        let pfn = PageFrameNumber::from_phys_addr(addr);
        assert_eq!(pfn.phys_addr(), PhysAddr::new(0x40400000));
    }
}
